# Graph Data Structures in Java

## `Q1`
a generic undirected graph implementation in Java using a HashMap. It allows us to create a graph, add vertices, add edges with weights, and also obtain a string representation of the graph. The code utilizes a HashMap named map to store all the Vertexes. Each key in the map represents a Vertex, and its corresponding value is a nested HashMap that stores the neighboring nodes as keys and their associated edge weights as values.

`addVertex(T node):` This method adds a vertex (node) to the graph. It creates a new entry in the map using the given node as the key and initializes an empty HashMap as the value to store its neighboring nodes and edge weights.

`addEdge(T r1, T r2, int w):` This method adds an undirected edge between two nodes (r1 and r2) with a given weight (w). If either r1 or r2 does not exist in the graph, it adds them as vertices using the addVertex() method. Then it updates the map by adding the corresponding entries for both nodes, associating their neighboring nodes and edge weights.

`toString():` This method provides a string representation of the graph. It first checks if the graph is empty, and if so, it returns the message "The Graph is Empty." Otherwise, it iterates over each vertex in the map and appends its neighbors and edge weights to a StringBuilder. The resulting string represents the graph as a list of vertices and their neighboring nodes along with the corresponding edge weights.

#### `Q1 1)` isConnected()
The provided code implements a method named isConnected() to determine whether a graph is connected or not. It utilizes a breadth-first search (BFS) traversal algorithm to explore the graph and track visited vertices. The method isConnected() checks whether the graph is connected or not and returns true if it is connected, or false otherwise. The code first checks if the graph is empty. If the map is empty, it immediately returns false since an empty graph is considered not connected by assumption. The code initializes a visited set to keep track of the visited vertices during the traversal. It also creates a queue using a LinkedList to perform the breadth-first search traversal. Additionally, it retrieves the set of all vertices in the graph from the map using keySet() and creates a for each loop to traverse the set. The traversal begins by adding the first vertex from the keySet to the queue and marking it as visited in the visited set. This is done by calling it.next() twice, assuming that there is at least one vertex in the graph. The code performs a breadth-first search traversal by iterating while the queue is not empty. In each iteration, it retrieves the current vertex from the front of the queue using queue.poll(). For the current vertex, the code iterates over its neighboring vertices obtained from the adjacency list in the map. It checks if a neighbor has not been visited yet by examining the visited set. If a neighbor is not visited, it is added to the queue for further exploration and marked as visited in the visited set. Once the traversal is complete and the queue becomes empty, the code checks if all vertices have been visited. It compares the size of the visited set with the total number of vertices in the graph obtained from map.size(). If they are equal, it means that all vertices have been visited, indicating that the graph is connected. In this case, the method returns true; otherwise, it returns false.

#### `Q1 2)` isCyclic()
The method checks whether the graph contains cycles or not. It prints a message indicating the presence or absence of cycles. Checks if the graph is empty, it prints a message indicating an empty graph and returns. Initializes the set visited to keep track of visited vertices. Iterates over each vertex in the graph. Checks if the vertex has not been visited yet. Calls the isCyclic2() helper method to check if the vertex is part of a cycle. If a cycle is found, it prints a message indicating the presence of a cycle and returns. If no cycles are found in the graph, it prints a message indicating the absence of cycles and returns. The helper method's purpose is to check if the graph contains a cycle starting from a specific vertex.

#### `Q1 3)` maximumFlow()
The maximum flow problem aims to determine the maximum amount of flow that can be sent from a source node to a target node in a graph. It is often implemented on a graph where edges have weights that represent the maximum amount of flow they can carry. We initialize the flow in all edges to 0. This represents that initially, no flow is passing through any of the edges. We can use breadth-first search (BFS) or depth-first search (DFS) to find these paths. While traversing the graph, we need to ensure that we only select edges with available capacity. Once we find an augmenting path, we can determine the maximum amount of flow that can be sent through this path. This value is equal to the minimum capacity of all edges in the path. We then update the flow along the path by adding this value to the flow of each edge and subtracting it from their capacity. Continue finding augmenting paths and updating the flow until no more augmenting paths can be found. This means that we have reached the maximum possible flow between the source and target nodes. To calculate the maximum flow, sum up the flows of all the edges leaving the source node. This represents the maximum total amount of flow that can be sent from the source to the target node. At last return the calculated maximum flow.
#### `Q2` Instances of the Graph
We try entering many different types of Graphs, such as

(i) This graph has 4 Vertices named A,B,C,D. They are connected internally with different weights with each other. Here is the image of what the tree looks like.

<img src="https://github.com/knox-cs220-s23/assignment-4-RIDHAMDD/assets/91961949/94bb5eb6-5c96-4e68-a5db-4722bce609f4"  width="275" height="150">

(ii) This graph has 0 Vertices. Hence, it an empty graph.

(iii) This graph has 4 Vertices named A,B,C,D. They are connected internally with different weights with each other. Here is the image of what the tree looks like.

<img src="https://github.com/knox-cs220-s23/assignment-4-RIDHAMDD/assets/91961949/b6b742ba-f958-4b48-ba5a-632deaf42e0a"  width="275" height="150">

(iv) This graph has 4 Vertices named A,B,C,D,E,F. They are connected internally with different weights with each other. We used this instance of graph to test Dijkstara's algorithm. Here is the image of what the tree looks like.

<img src="https://github.com/knox-cs220-s23/assignment-4-RIDHAMDD/assets/91961949/62b8a452-d422-4a5f-8f79-805996920485"  width="275" height="150">

(v) This graph has 4 Vertices named A,B,C,D,E,F. They are connected internally with different weights with each other. We used this instance of the graph to test the Bipartiteness of a graph.  Here is the image of what the tree looks like.

<img src="https://github.com/knox-cs220-s23/assignment-4-RIDHAMDD/assets/91961949/bb2947af-ae5f-4157-b814-60cdb38cf953"  width="275" height="150">

(vi) This graph has 5 Vertices named 0,1,2,3,4. They are connected internally with some weights with each other. We used this instance of graph to test out PageRank Algorithm. Here is the image of what the tree looks like.
<img src="https://github.com/knox-cs220-s23/assignment-4-RIDHAMDD/assets/91961949/dca81f9b-e528-4163-8a3f-5000d385e4d6"  width="275" height="200">


(vii) This graph has 4 Vertices named 0,1,2,3. They are connected internally with some weights with each other. We used this instance of the graph to test out PageRank Algorithm. Here is the image of what the tree looks like.
<img src="https://github.com/knox-cs220-s23/assignment-4-RIDHAMDD/assets/91961949/b963732a-655f-4e6d-a206-5b87fb2d1757"  width="275" height="200">




#### `Q3` Dijkstraâ€™s algorithm
The Method Dijkstra takes two parameters, t1, and t2, representing the source and destination vertices, respectively. It initializes an empty list called path which will store the shortest path from t1 to t2. The algorithm begins by checking if both t1 and t2 are present in the graph. If either of them is not present, it prints a message mentioning that one of the given vertices is not in the graph. It adds null to the path and returns it. Next, it initializes two maps that are distance and prevNode. The distance map will store the shortest distances from the source vertex to all other vertices, and the prevNode map will keep track of the previous vertex in the shortest path from the source to each vertex. The algorithm defines a class GComparator which implements the Comparator interface. This class is used to compare vertices based on their distances in the distance map. A priority queue named q is created using the GComparator to prioritize vertices based on their distances. This queue will be used to extract vertices with the minimum distance. The algorithm iterates over all vertices in the graph (map.keySet()), initializes their distances to infinity (Integer.MAX_VALUE), sets their previous nodes to null, and adds them to the priority queue. The distance of the source vertex t1 is set to 0, as the distance from t1 to itself is always 0. The main part of the algorithm starts with a loop that continues until the priority queue q becomes empty. Inside the loop, it extracts the vertex with the minimum distance from the priority queue and assigns it to the variable curr. It then iterates over the neighbors of curr (retrieved from map.get(curr).keySet()), which are the vertices adjacent to curr in the graph. For each neighbor vertex v, it checks if v is still in the priority queue (q.contains(v)) or if v is the destination vertex t2. This is done to ensure that only reachable vertices are considered and to terminate the algorithm early if t2 is reached. If the condition is satisfied it compares the distance from t1 to v through the current vertex curr (distance.get(curr) + map.get(curr).get(v)) with the current known distance to v (distance.get(v)). If the newly calculated distance is shorter, it updates distance[v] and sets prevNode[v] to curr.
Once the loop finishes, the shortest path from t1 to t2 has been found. Starting from t2, the algorithm reconstructs the shortest path by following the prevNode map. It adds each vertex to the path list and assigns the previous node of the current vertex to curr. The loop continues until it reaches the source vertex t1. At this point, the complete path from t1 to t2 has been built in reverse order.
Finally, the source vertex t1 is added to the path, and the path list is reversed to obtain the correct order of vertices from t1 to t2.
The Method returns the path list.

The other algorithm which is an alternative to Dijkstara's algorithm is the Bellman-Ford algorithm. The main difference between these two is Dijkstara can compute the shortest distance in a graph only if all weights are nonnegative. But also Dijkstara's algorithm is of low complexity compared to the rather. While for the Bellman-Ford algorithm, it is capable to deal with negative weights given the fact that it is a directed graph. Having Negative weights in an undirected graph fails both Dijkstara's and Bellman Ford's algorithms. The time complexity of Bellman-Ford is more than Dijkstara.

#### `Q4` isBipartite()
Method `isBipartite(Graph<T> graph);`

This method takes a graph as input and returns a boolean value indicating whether the graph is bipartite or not. It first checks if the graph is empty. If it is, the method considers an empty graph as not bipartite and returns false. The method initializes a set called visited to keep track of visited vertices and a map called colorMap to assign colors to vertices It then iterates over each vertex in the graph. If a vertex has not been visited yet, it calls the isBipartite2() helper method to check if the graph is bipartite starting from that vertex. If isBipartite2() returns true, indicating that the graph is bipartite, it prints a message stating that the graph is bipartite and returns true. If the method completes the iteration without finding a bipartite configuration, it prints a message stating that the graph is not bipartite and returns false.

Method `isBipartite2(Graph<T> graph, T vertex, Set<T> visited, Map<T, Integer> colorMap);`

This helper method takes a graph, a current vertex, a set of visited vertices, and a color map as input. It performs a breadth-first search (BFS) traversal to check for bipartite ness starting from the given vertex. It uses a queue to store vertices to be processed in the BFS traversal. The method initializes the queue by adding the current vertex, marks it as visited and assigns color 0 to it in the color map. It then enters a loop where it continues until the queue becomes empty. In each iteration, it dequeues a vertex from the queue and retrieves its color from the color map. It iterates over the neighbors of the current vertex obtained from the graph's adjacency list. If a neighbor has not been visited, it adds it to the queue, marks it as visited, and assigns the opposite color (1 - currColor) to it in the color map. If a neighbor has been visited and has the same color as the current vertex, it indicates a violation of bipartite ness, and the method returns false. If the method completes the traversal without finding any violations, it returns true, indicating that the graph is bipartite.


#### `Q5` implementation of PageRank Algorithm

Method `initializePageRank():`
This method initializes the PageRank algorithm by setting up the initial ranks, arrays, and contributions for each vertex in the graph. It starts by calculating the total number of vertices in the graph using map.keySet().size(). The initial rank for each vertex is calculated as 1.0 / totalVertex, where totalVertex is the total number of vertices. Three arrays (PageRank, old_pageRank, and contribution) are initialized to store the page ranks, old page ranks, and contributions of each vertex, respectively. They are assigned sizes equal to totalVertex. The PageRank and old_pageRank arrays are filled with the initial rank using Arrays.fill(PageRank, initialRank) and Arrays.fill(old_pageRank, initialRank). The contribution of each vertex is calculated by iterating over each vertex index (i) from 0 to totalVertex - 1 and assigning it the size of the corresponding vertex's neighbors, accessed through map.get(i).size().

Method `PageRank(int round):`
This method performs the PageRank algorithm for the specified number of rounds. It starts by calling the initializePageRank() method to set up the initial page ranks, arrays, and contributions. The total number of vertices is obtained again using map.keySet().size() and stored in totalVertex. A new array called newPageRankArray is created with a size equal to totalVertex to store the updated page ranks in each round. The PageRank algorithm is executed for the specified number of rounds. In each round, the newPageRankArray is filled with zeros using Arrays.fill(newPageRankArray, 0). The current page ranks are copied to the old_pageRank array using Arrays.copyOf(PageRank, PageRank.length). The algorithm then iterates over each vertex v in the graph (map.keySet()), and for each vertex v, it iterates over all vertices u in the graph again. For each combination of v and u, it checks if there is an edge from u to v by using map.get(u).containsKey(v). If there is an edge from u to v, it updates the new page rank for v by adding the old page rank of u divided by the contribution of u to the current value of newPageRankArray[(int)v]. Here we assumed that the given graph is an Integer graph. After calculating the new page ranks for all vertices, the PageRank array is updated by copying the values from newPageRankArray using PageRank = Arrays.copyOf(newPageRankArray, newPageRankArray.length). This process is repeated for the specified number of rounds.
